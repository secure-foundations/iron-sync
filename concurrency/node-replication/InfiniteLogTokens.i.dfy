include "InfiniteLog.i.dfy"
include "Constants.i.dfy"

module InfiniteLogTokens(nrifc: NRIfc) {
  import opened RequestIds
  import opened Options
  import opened IL = InfiniteLogSSM(nrifc)
  import opened GhostLoc
  import opened ILT = TicketStubToken(nrifc, IL)
  import opened Constants

  function loc() : Loc // XXX TODO(travis)

  /////////////////////
  // Token types. These represent the smallest discrete parts of the InfiniteLog state.
  // This is a way of dividing up the state into the pieces it will be convenient to
  // manipulate in our program.

  datatype {:glinear_fold} Readonly = Readonly(rid: RequestId, rs: ReadonlyState)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[], None, map[], map[], None, map[rid := rs], map[], map[])
      )
    }
  }

  datatype {:glinear_fold} Update = Update(rid: RequestId, us: UpdateState)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[], None, map[], map[], None, map[], map[rid := us], map[])
      )
    }
  }

  datatype {:glinear_fold} Ctail = Ctail(ctail: nat)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[], None, map[], map[], Some(ctail), map[], map[], map[])
      )
    }
  }

  datatype {:glinear_fold} LocalTail = LocalTail(nodeId: NodeId, localTail: nat)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[], None, map[], map[nodeId := localTail], None, map[], map[], map[])
      )
    }
  }

  datatype {:glinear_fold} GlobalTail = GlobalTail(tail: nat)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[], Some(tail), map[], map[], None, map[], map[], map[])
      )
    }
  }

  datatype {:glinear_fold} Replica = Replica(nodeId: NodeId, state: nrifc.NRState)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[], None, map[nodeId := state], map[], None, map[], map[], map[])
      )
    }
  }

  datatype {:glinear_fold} CombinerToken = CombinerToken(nodeId: NodeId, state: CombinerState)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[], None, map[], map[], None, map[], map[], map[nodeId := state])
      )
    }
  }

  datatype {:glinear_fold} Log = Log(idx: nat, op: nrifc.UpdateOp, node_id: NodeId)
  {
    function defn(): ILT.Token {
      ILT.Tokens.Token(loc(),
        M(map[idx := LogEntry(op, node_id)], None, map[], map[], None, map[], map[], map[])
      )
    }
  }

  /////////////////////
  // The transitions.
  // These let us transform ghost state into other ghost state to represent
  // InfiniteLog transitions.

  // This lets us perform the transition
  //
  //    Readonly(rid, ReadonlyInit(op))         , Ctail(ctail)
  //      -->
  //    Readonly(rid, ReadonlyCtail(op, ctail)) , Ctail(ctail)
  //
  // which is effectively the `TransitionReadonlyReadCtail` transition.
  //
  // Note that it takes a `glinear` Readonly object and returns a new `glinear` Readonly
  // object. Since we only read from `ctail`, we don't need to update it, so we pass in
  // a `gshared` Ctail object. (This can be thought of a a readonly borrowed reference
  // to the Ctail object).

  glinear method perform_TransitionReadonlyReadCtail(
      glinear readonly: Readonly,
      gshared ctail: Ctail)
  returns (glinear readonly': Readonly)
  requires readonly.rs.ReadonlyInit?
  ensures readonly' == Readonly(readonly.rid, ReadonlyCtail(readonly.rs.op, ctail.ctail))
  {
    // Unfold the inputs to get the raw tokens as defined by the `defn` functions.
    // (These are glinear methods auto-generated by the {:glinear_fold} attribute.)
    glinear var a_token := Readonly_unfold(readonly);
    gshared var s_token := Ctail_unfold_borrow(ctail); // use `borrow` for `gshared` types.

    // Compute the things we want to output (as ghost, _not_ glinear constructs)
    ghost var out_expect := Readonly(readonly.rid, ReadonlyCtail(readonly.rs.op, ctail.ctail));
    ghost var out_token_expect := Readonly_unfold(out_expect);

    // Explain what transition we're going to do
    assert IL.NextStep(
        IL.dot(s_token.val, a_token.val),
        IL.dot(s_token.val, out_token_expect.val),
        TransitionReadonlyReadCtail_Step(readonly.rid));

    // Perform the transition
    // 1_1_1 indicates:
    //    1 shared input (b)
    //    1 linear input (a)
    //    1 linear output (o)
    glinear var out_token := ILT.transition_1_1_1(s_token, a_token, out_token_expect.val);

    // Fold the raw token into the Readonly datatype
    // Readonly_fold is another auto-generated glinear method.
    readonly' := Readonly_fold(out_expect, out_token);
  }

  //    Readonly(rid, ReadonlyCtail(op, ctail))               , LocalTail(nodeId, ltail)
  //      -->
  //    Readonly(rid, ReadonlyReadyToRead(op, nodeId, ctail)) , LocalTail(nodeId, ltail)

  glinear method perform_TransitionReadonlyReadyToRead(
      glinear ticket: Readonly,
      gshared ltail: LocalTail)
  returns (glinear ticket': Readonly)
  requires ticket.rs.ReadonlyCtail?
  // requires ltail.localTail >= ticket.rs.ctail
  ensures ticket' == Readonly(ticket.rid,
      ReadonlyReadyToRead(ticket.rs.op, ltail.nodeId, ticket.rs.ctail))
  {
    // Unfold the inputs to get the raw tokens as defined by the `defn` functions.
    // (These are glinear methods auto-generated by the {:glinear_fold} attribute.)
    glinear var a_token := Readonly_unfold(ticket);
    gshared var s_token := LocalTail_unfold_borrow(ltail); // use `borrow` for `gshared` types.

    // Compute the things we want to output (as ghost, _not_ glinear constructs)
    //     | ReadonlyReadyToRead(op: nrifc.ReadonlyOp, nodeId: NodeId, ctail: nat)

    ghost var out_expect := Readonly(ticket.rid, ReadonlyReadyToRead(ticket.rs.op, ltail.nodeId, ticket.rs.ctail));
    ghost var out_token_expect := Readonly_unfold(out_expect);

    // Explain what transition we're going to do
    assert IL.NextStep(
        IL.dot(s_token.val, a_token.val),
        IL.dot(s_token.val, out_token_expect.val),
        TransitionReadonlyReadyToRead_Step(ltail.nodeId, ticket.rid));

    // Perform the transition
    // 1_1_1 indicates:
    //    1 shared input (b)
    //    1 linear input (a)
    //    1 linear output (o)
    glinear var out_token := ILT.transition_1_1_1(s_token, a_token, out_token_expect.val);

    // Fold the raw token into the Readonly datatype
    // Readonly_fold is another auto-generated glinear method.
    ticket' := Readonly_fold(out_expect, out_token);
  }

  //    Readonly(rid, ReadonlyReadyToRead(op, nodeId, ctail)) , Replica(nodeId, state)
  //      -->
  //    Readonly(rid, ReadonlyDone(ret))                      , Replica(nodeId, state)

  glinear method perform_ReadonlyDone(
      glinear readonly: Readonly,
      gshared replica: Replica)
  returns (glinear readonly': Readonly)
  requires readonly.rs.ReadonlyReadyToRead?
  requires replica.nodeId == readonly.rs.nodeId
  ensures readonly' == Readonly(readonly.rid,
      ReadonlyDone(readonly.rs.op, nrifc.read(replica.state, readonly.rs.op), readonly.rs.nodeId, readonly.rs.ctail))
  //{
    //TODO
  //}

  glinear method perform_TrivialStartCombining(
      glinear combiner: CombinerToken)
  returns (
      glinear combiner': CombinerToken
  )
  requires combiner.state.CombinerReady?
  ensures combiner' == CombinerToken(combiner.nodeId, CombinerPlaced([]))
  // TODO (this requires a new transition, it's a much simpler version of AdvanceTail)

  glinear method perform_AdvanceTail(
      glinear tail: GlobalTail,
      glinear updates: map<nat, Update>,
      glinear combiner: CombinerToken,
      ghost ops: seq<nrifc.UpdateOp>,
      ghost requestIds: seq<RequestId>,
      ghost nodeId: NodeId)
  returns (
      glinear tail': GlobalTail,
      glinear updates': map<nat, Update>,
      glinear combiner': CombinerToken,
      glinear logs': map<nat, Log>
  )
  requires |ops| == |requestIds|
  requires forall i | 0 <= i < |requestIds| ::
      i in updates && updates[i] == Update(requestIds[i], UpdateInit(ops[i]))
  requires combiner.nodeId == nodeId
  requires combiner.state == CombinerReady
  ensures tail' == GlobalTail(tail.tail + |ops|)
  ensures forall i | 0 <= i < |requestIds| ::
      i in updates'
        && updates'[i].us.UpdatePlaced?
        && updates'[i] == Update(requestIds[i], UpdatePlaced(nodeId, updates'[i].us.idx))
  ensures forall i | 0 <= i < |requestIds| ::
      i in logs'
        && logs'[i] == Log(tail.tail + i, ops[i], nodeId)
  ensures combiner'.nodeId == nodeId
  ensures combiner'.state == CombinerPlaced(requestIds)
  // TODO this one is advanced

  glinear method perform_ExecLoadLtail(
      glinear combiner: CombinerToken,
      gshared ltail: LocalTail)
  returns (glinear combiner': CombinerToken)
  requires ltail.nodeId == combiner.nodeId
  requires combiner.state.CombinerPlaced?
  ensures combiner' == combiner.(state :=
      CombinerLtail(combiner.state.queued_ops, ltail.localTail))

  glinear method perform_ExecLoadGlobalTail(
      glinear combiner: CombinerToken,
      gshared globalTail: GlobalTail)
  returns (glinear combiner': CombinerToken)
  requires combiner.state.CombinerLtail?
  ensures combiner' == combiner.(state :=
      Combiner(combiner.state.queued_ops, combiner.state.localTail, globalTail.tail))
  ensures combiner'.state.globalTail >= combiner'.state.localTail // follows from state machine invariant

  glinear method perform_UpdateCompletedTail(
      glinear combiner: CombinerToken,
      glinear ctail: Ctail)
  returns (glinear combiner': CombinerToken, glinear ctail': Ctail)
  requires combiner.state.Combiner?
  requires combiner.state.localTail == combiner.state.globalTail
  ensures combiner' == combiner.(state :=
      CombinerUpdatedCtail(combiner.state.queued_ops, combiner.state.localTail))
  ensures ctail' == Ctail(if ctail.ctail > combiner.state.localTail
      then ctail.ctail else combiner.state.localTail)

  glinear method perform_GoToCombinerReady(
      glinear combiner: CombinerToken,
      glinear localTail: LocalTail)
  returns (glinear combiner': CombinerToken, glinear localTail': LocalTail)
  requires combiner.state.CombinerUpdatedCtail?
  requires combiner.nodeId == localTail.nodeId
  ensures combiner' == combiner.(state := CombinerReady)
  ensures localTail' == localTail.(localTail := combiner.state.localAndGlobalTail)
  {
    glinear var a_token := CombinerToken_unfold(combiner);
    glinear var b_token := LocalTail_unfold(localTail);

    // Compute the things we want to output (as ghost, _not_ glinear constructs)
    ghost var out1_expect := combiner.(state := CombinerReady);
    ghost var out1_token_expect := CombinerToken_unfold(out1_expect);

    ghost var out2_expect := localTail.(localTail := combiner.state.localAndGlobalTail);
    ghost var out2_token_expect := LocalTail_unfold(out2_expect);

    // Explain what transition we're going to do
    assert GoToCombinerReady(
        IL.dot(a_token.val, b_token.val),
        IL.dot(out1_token_expect.val, out2_token_expect.val),
        localTail.nodeId);
    assert IL.NextStep(
        IL.dot(a_token.val, b_token.val),
        IL.dot(out1_token_expect.val, out2_token_expect.val),
        GoToCombinerReady_Step(localTail.nodeId));

    // Perform the transition
    glinear var out1_token, out2_token := ILT.transition_2_2(a_token, b_token,
        out1_token_expect.val,
        out2_token_expect.val);

    combiner' := CombinerToken_fold(out1_expect, out1_token);
    localTail' := LocalTail_fold(out2_expect, out2_token);
  }

  glinear method perform_ExecDispatchRemote(
      glinear combiner: CombinerToken,
      glinear replica: Replica,
      gshared log_entry: Log)
  returns (
      glinear combiner': CombinerToken,
      glinear replica': Replica
    )
  requires combiner.nodeId == replica.nodeId
  requires combiner.nodeId != log_entry.node_id
  requires combiner.state.Combiner?
  requires log_entry.idx == combiner.state.localTail
  requires combiner.state.localTail < combiner.state.globalTail
  ensures combiner' == combiner.(state := combiner.state.(localTail := combiner.state.localTail + 1))
  ensures replica' == replica.(state := nrifc.update(replica.state, log_entry.op).new_state)
  {
    glinear var a_token := CombinerToken_unfold(combiner);
    glinear var b_token := Replica_unfold(replica);
    gshared var s_token := Log_unfold_borrow(log_entry);

    // Compute the things we want to output (as ghost, _not_ glinear constructs)
    ghost var out1_expect := combiner.(state := combiner.state.(localTail := combiner.state.localTail + 1));
    ghost var out1_token_expect := CombinerToken_unfold(out1_expect);

    ghost var out2_expect := replica.(state := nrifc.update(replica.state, log_entry.op).new_state);
    ghost var out2_token_expect := Replica_unfold(out2_expect);

    // Explain what transition we're going to do
    assert ExecDispatchRemote(
        IL.dot(s_token.val, IL.dot(a_token.val, b_token.val)),
        IL.dot(s_token.val, IL.dot(out1_token_expect.val, out2_token_expect.val)),
        combiner.nodeId);
    assert IL.NextStep(
        IL.dot(s_token.val, IL.dot(a_token.val, b_token.val)),
        IL.dot(s_token.val, IL.dot(out1_token_expect.val, out2_token_expect.val)),
        ExecDispatchRemote_Step(combiner.nodeId));

    // Perform the transition
    glinear var out1_token, out2_token := ILT.transition_1_2_2(s_token, a_token, b_token,
        out1_token_expect.val,
        out2_token_expect.val);

    combiner' := CombinerToken_fold(out1_expect, out1_token);
    replica' := Replica_fold(out2_expect, out2_token);
  }

  glinear method perform_ExecDispatchLocal(
      glinear combiner: CombinerToken,
      glinear replica: Replica,
      glinear update: Update,
      gshared log_entry: Log)
  returns (
      glinear combiner': CombinerToken,
      glinear replica': Replica,
      glinear update': Update
    )
  requires combiner.nodeId == replica.nodeId
  requires combiner.nodeId == log_entry.node_id
  requires combiner.state.Combiner?
  requires log_entry.idx == combiner.state.localTail
  // TODO XXX this condition is not enough
  requires update.us.UpdatePlaced?
  ensures combiner' == combiner.(state := combiner.state.(localTail := combiner.state.localTail + 1))
  ensures replica' == replica.(state := nrifc.update(replica.state, log_entry.op).new_state)
  ensures update' == update.(us := UpdateApplied(
      nrifc.update(replica.state, log_entry.op).return_value,
      update.us.idx))

  glinear method perform_UpdateDone(
      ghost n: nat,
      glinear updates: map<nat, Update>,
      gshared combiner: CombinerToken)
  returns (
      glinear updates': map<nat, Update>)
  requires combiner.state.CombinerUpdatedCtail?
  // TODO XXX this condition is not enough
  requires forall i | 0 <= i < n :: i in updates && updates[i].us.UpdateApplied?
  ensures forall i | 0 <= i < n ::
      && i in updates'
      && updates'[i] == Update(updates[i].rid, UpdateDone(updates[i].us.ret, updates[i].us.idx))
  // TODO needs to do the UpdateDone transition in a loop

  glinear method perform_Init(glinear token: ILT.Token)
  returns (
      glinear globalTail: GlobalTail,
      glinear replicas: map<nat, Replica>,
      glinear localTails: map<nat, LocalTail>,
      glinear ctail: Ctail,
      glinear combiners: map<nat, CombinerToken>
  )
  requires token.loc == loc()
  requires IL.Init(token.val)
  ensures globalTail.tail == 0
  ensures ctail.ctail == 0
  ensures forall i | 0 <= i < NUM_REPLICAS as int ::
      i in replicas && i in localTails && i in combiners
      && replicas[i] == Replica(i, nrifc.init_state())
      && localTails[i] == LocalTail(i, 0)
      && combiners[i] == CombinerToken(i, CombinerReady)
}
